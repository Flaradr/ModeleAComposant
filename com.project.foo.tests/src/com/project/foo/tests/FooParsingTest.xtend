/*
 * generated by Xtext 2.13.0
 */
package com.project.foo.tests

import com.google.inject.Inject
import com.project.foo.foo.DomainModel
import com.project.foo.foo.FooPackage
import com.project.foo.validation.FooValidator
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*

@RunWith(XtextRunner)
@InjectWith(FooInjectorProvider)
class FooParsingTest {
	@Inject extension ParseHelper<DomainModel>
	@Inject extension ValidationTestHelper

	val static validComponent = '''
		package toto {
			Component A{
				provided = {m1,m2}
				requiered = {m3}

				service provided type2 m1(p1 : type2) {}
				service provided type1 m2(p2 : type1) {}

				service requiered type3 m3();
			}
		}'''

	/**
	 * Test si le composant est valide ou non
	 */
	@Test
	def void testParsingComponent() {
		val input = parse(validComponent)
		assertNotNull(input)
		val errors = input.eResource.errors
		val component = input.models.get(0).component.get(0)
		assertEquals("A",component.name)

		/*Comment tester égalités entre tableau alors qu'il faudrait mapper
		 * .name à chaque attribut de component.provided.providedServices
		 * et component.requiered.requieredServices ?
		 */
		//assertEquals("[m1,m2]",component.provided.providedServices)
		//assertEquals("[m3]",component.requiered.requieredServices)

		assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)


	}

	/**
	 * Test la methode checkComponentNameStartsWithCapital
	 */
	@Test
	def void testCheckComponentNameStartsWithCapital(){
		validComponent.parse.assertNoIssues()

		val input = '''
			package toto {
				Component a{
					provided = {m1}
					requiered = {}

					service provided type2 m1(p1 : type2) {}
				}
			}
		'''
		input.parse.assertWarning(
			FooPackage.Literals.COMPONENT,
			FooValidator.CHECK_C_NAME_START_W_CAPITAL,
			input.indexOf("Component a")+"Component ".length,
			1,
			"Name should start with a capital")
	}

	/**
	 * Test la methode checkAssemblyNameStartsWithCapital
	 */
	@Test
	def void testCheckAssemblyNameStartsWithCapital(){
		val inputOk = '''
			package toto {
				Component A{
					provided = {m1}
					requiered = {}

					service provided type2 m1(p1 : type2) {}
				}
				Component B{
					provided = {m2}
					requiered = {}

					service provided type2 m2(p1 : type2) {}
				}
				Assembly D{
					components
					a1 : A
					b1 : B
					bindings
				}
			}
		'''
		inputOk.parse.assertNoIssues()

		val input = '''
			package toto {
				Component A{
					provided = {m1}
					requiered = {}

					service provided type2 m1(p1 : type2) {}
				}
				Component B{
					provided = {m2}
					requiered = {}

					service provided type2 m2(p1 : type2) {}
				}
				Assembly d{
					components
					a1 : A
					b1 : B
					bindings
				}
			}
		'''
		input.parse.assertWarning(
			FooPackage.Literals.ASSEMBLY,
			FooValidator.CHECK_A_NAME_START_W_CAPITAL,
			input.indexOf("Assembly d")+"Assembly ".length,	//Ajout de "Assembly ".length pour eviter ambiguite
			1,
			"Name should start with a capital")
	}

	/*************************************************************
	 * 				Test check unicite nom						 *
	 * ********************************************************* */
	/**
	 * Test la methode checkComponentNameIsUnique
	 */
	@Test
	def void testCheckComponentNameIsUnique(){
		validComponent.parse.assertNoIssues()

		val input = '''
			package toto {
				Component A{
					provided = {m1,m2}
					requiered = {m3}

					service provided type2 m1(p1 : type2) {}
					service provided type1 m2(p2 : type1) {}

					service requiered type3 m3();
				}
				Component A{
					provided = {m7}
					requiered = {}

					service provide type1 m7() {}
				}
			}
		'''
		input.parse.assertError(
			FooPackage.Literals.COMPONENT,
			FooValidator.CHECK_COMPONENT_NAME_IS_UNIQUE,
			input.indexOf("Component A")+"Component ".length,
			1,
			"The name of a component should be unique")
		}

	/**
	 * Test la methode checkAssemblyNameIsUnique
	 */
	@Test
	def void testCheckAssemblyNameIsUnique(){
		val inputOk = '''
		package toto {
			Component A{
				provided = {m1}
				requiered = {}

				service provided type2 m1(p1 : type2) {}
			}
			Component B{
				provided = {m2}
				requiered = {}

				service provided type2 m2(p1 : type2) {}
			}
			Assembly D{
				components
				a1 : A
				b1 : B
				bindings
			}
			Assembly F{
				components
				a1 : A
				b2 : B
				bindings
			}
		}
		'''
		inputOk.parse.assertNoIssues()

		val input = '''
		package toto {
			Component A{
				provided = {m1}
				requiered = {}

				service provided type2 m1(p1 : type2) {}
			}
			Component B{
				provided = {m2}
				requiered = {}

				service provided type2 m2(p1 : type2) {}
			}
			Assembly D{
				components
				a1 : A
				b1 : B
				bindings
			}
			Assembly D{
				components
				a1 : A
				b2 : B
				bindings
			}
		}
		'''
		input.parse.assertError(
			FooPackage.Literals.ASSEMBLY,
			FooValidator.CHECK_ASSEMBLY_NAME_IS_UNIQUE,
			input.indexOf("Assembly D")+"Assembly ".length,
			1,
			"The name of an assembly should be unique")
	}

	/**
	 * Teste la methode checkComponentAttributeNameIsUnique
	 */
	@Test
	def void testCheckComponentAttributeNameIsUnique(){
		val inputOk = '''
		package toto {
			Component A{
				provided = {m1}
				requiered = {}

				service provided type2 m1(p1 : type2) {}
			}
			Component B{
				provided = {m2}
				requiered = {}

				service provided type2 m2(p1 : type2) {}
			}
			Assembly D{
				components
				a1 : A
				b1 : B
				bindings
			}
		}
		'''
		inputOk.parse.assertNoIssues()

		val input = '''
		package toto {
			Component A{
				provided = {m1}
				requiered = {}

				service provided type2 m1(p1 : type2) {}
			}
			Component B{
				provided = {m2}
				requiered = {}

				service provided type2 m2(p1 : type2) {}
			}
			Assembly D{
				components
				a1 : A
				a1 : B
				b1 : B
				bindings
			}
		}
		'''
		input.parse.assertError(
			FooPackage.Literals.COMPONENT_ATTRIBUTE,
			FooValidator.CHECK_COMPONENT_ATTRIBUTE_NAME_IS_UNIQUE,
			input.indexOf("a1"),
			2,
			"The name of a component attribute should be unique")
	}

	/**
	 * Teste la methode checkProvidedServiceNameIsUnique
	 */
	@Test
	def void testCheckProvidedServiceNameIsUnique(){
		validComponent.parse.assertNoIssues()

		val input = '''
			package toto {
				Component A{
					provided = {m1,m1}
					requiered = {}

					service provided type1 m1() {}
				}
			}
			'''
		input.parse.assertError(
			FooPackage.Literals.PROVIDED_SERVICE,
			FooValidator.CHECK_P_SERVICE_NAME_IS_UNIQUE,
			input.indexOf("m1"),
			2,
			"The name of a provided service should be unique in a component")
	}


	/**
	 * Teste la methode checkRequieredServiceNameIsUnique
	 */
	@Test
	def void testCheckRequieredServiceNameIsUnique(){
		validComponent.parse.assertNoIssues()

		val input = '''
			package toto{
				Component A{
					provided = {m1}
					requiered = {m2,m2}

					service provided type1 m1() {}
					service requiered type3 m2();
				}
			}
			'''
		input.parse.assertError(
			FooPackage.Literals.REQUIERED_SERVICE,
			FooValidator.CHECK_R_SERVICE_NAME_IS_UNIQUE,
			input.indexOf("m2"),
			2,
			"The name of a requiered service should be unique in a component")
	}

	/*************************************************************
	 * 				Test check validite binding					 *
	 * ********************************************************* */

	/**
	 * Teste la methode CheckBindingIsValid
	 */
	@Test
	def void testCheckBindingIsValid(){
		val inputOk = '''
			package toto {
			  	Component A{
			  		provided = {m0}
			  		requiered = {m1}

			  		service provided type0 m0() {}
			  		service requiered type1 m1 ();
			  	}

			  	Component B{
			  		provided = {m2}
			  		requiered = {}

			  		service provided type1 m2(){}
			  	}

			  	Assembly T{
			  		components
			  		a1 : A
			  		b1 : B
			  		bindings
			  		a1.A.m1 - b1.B.m2
			  	}
			}
	  	'''
	  	inputOk.parse.assertNoIssues()

	  	val input1 = '''
			package toto {
			  	Component A{
			  		provided = {m0}
			  		requiered = {m1}

			  		service provided type0 m0() {}
			  		service requiered type1 m1 (p1 : type1, p2 : type2);
			  	}

			  	Component B{
			  		provided = {m2}
			  		requiered = {}

			  		service provided type2 m2(p21 : type1, p22 : type2){}
			  	}

			  	Assembly T{
			  		components
			  		a1 : A
			  		b1 : B
			  		bindings
			  		a1.A.m1 - b1.B.m2
			  	}
			 }
	  	'''
	  	input1.parse.assertError(
	  		FooPackage.Literals.BINDING,
	  		FooValidator.CHECK_BINDING_IS_VALID,
	  		input1.indexOf("b1.B.m2"),
	  		"b1.B.m2".length,
	  		"Return type of the provided service do not match the return type of the requiered service")

	  	val input2 = '''
			package toto {
			  	Component A{
			  		provided = {m0}
			  		requiered = {m1}

			  		service provided type0 m0() {}
			  		service requiered type2 m1 (p1 : type1, p2 : type2);
			  	}

			  	Component B{
			  		provided = {m2}
			  		requiered = {}

			  		service provided type2 m2(p7 : type1, p3 : type3){}
			  	}

			  	Assembly T{
			  		components
			  		a1 : A
			  		b1 : B
			  		bindings
			  		a1.A.m1 - b1.B.m2
			  	}
			 }
	  	'''
	  	input2.parse.assertError(
	  		FooPackage.Literals.BINDING,
	  		FooValidator.CHECK_BINDING_IS_VALID,
	  		input2.indexOf("b1.B.m2"),
	  		"b1.B.m2".length,
	  		"The type of the parameters of the requiered service and the provided service do not match")

	  	val input3 = '''
			package toto {
			  	Component A{
			  		provided = {m0}
			  		requiered = {m1}

			  		service provided type0 m0() {}
			  		service requiered type2 m1 (p1 : type1, p2 : type2, p3 : type0);
			  	}

			  	Component B{
			  		provided = {m2}
			  		requiered = {}

			  		service provided type2 m2(p7 : type1, p3 : type3){}
			  	}

			  	Assembly T{
			  		components
			  		a1 : A
			  		b1 : B
			  		bindings
			  		a1.A.m1 - b1.B.m2
			  	}
			}
	  	'''
	  	input3.parse.assertError(
	  		FooPackage.Literals.BINDING,
	  		FooValidator.CHECK_BINDING_IS_VALID,
	  		input3.indexOf("b1.B.m2"),
	  		"b1.B.m2".length,
	  		"Number of parameters between the requiered service and the provided service do not match")

	}

	/**
	 * Teste la methode checkProvidedServiceHasMethod
	 */
	@Test
	def void testCheckProvidedServiceHasMethod(){
		validComponent.parse.assertNoIssues()

		val input = '''
		package toto {
			Component A{
				provided = {m1}
				requiered = {m2}

				service requiered type3 m2();
			}
		}
		'''
		input.parse.assertError(
			FooPackage.Literals.PROVIDED_SERVICE,
			FooValidator.CHECK_P_SERVICE_HAS_METHOD,
			input.indexOf("m1"),
			"m1".length,
			"The service needs a method declaration")
	}

	/**
	 * Teste la methode checkRequieredServiceHasMethod
	 */
	@Test
	def void testCheckRequieredServiceHasMethod(){
		validComponent.parse.assertNoIssues()

		val input = '''
		package toto {
			Component A{
				provided = {m1}
				requiered = {m2}

				service provided type1 m1() {}
			}
		}
		'''
		input.parse.assertError(
			FooPackage.Literals.REQUIERED_SERVICE,
			FooValidator.CHECK_R_SERVICE_HAS_METHOD,
			input.indexOf("m2"),
			"m2".length,
			"The service needs a method declaration")
	}

	/**
	 * Teste la mmethode checkAssemblyIsCorrect
	 */
	@Test
	def void testCheckAssemblyIsCorrect(){
		val inputOk = '''
			package toto {
				Component A{
					provided = {m1,m2}
					requiered = {m3}

					service provided type2 m1(p1 : type1) {}
					service provided void m2() {}

					service requiered type3 m3(p2 : type4);
				}

				Component B{
					provided = {m4}
					requiered = {m1}

					service provided type3 m4 (p4 : type4) { }

					service requiered type2 m1 (p3 : type1);
				}

				Assembly Foo{
					components
					a1 : A
					a2 : A
					b1 : B
					bindings
					a1.A.m3 - b1.B.m4
					a2.A.m3 - b1.B.m4
					b1.B.m1 - a1.A.m1
				}
			}
		'''
		inputOk.parse.assertNoIssues

		val input = '''
			package toto {
				Component A{
					provided = {m1,m2}
					requiered = {m3}

					service provided type2 m1(p1 : type1) {}
					service provided void m2() {}

					service requiered type3 m3(p2 : type4);
				}

				Component B{
					provided = {m4}
					requiered = {m1}

					service provided type3 m4 (p4 : type4) { }

					service requiered type2 m1 (p3 : type1);
				}

				Assembly Foo{
					components
					a1 : A
					a2 : A
					b1 : B
					bindings
					a1.A.m3 - b1.B.m4
					b1.B.m1 - a1.A.m1
				}
			}
		'''
		input.parse.assertError(
			FooPackage.Literals.ASSEMBLY,
			FooValidator.CHECK_ASSEMBLY_IS_VALID,
			input.indexOf("Foo"),
			"Foo".length,
			"The assembly is not correct, there are missing bindings")

		val input2 = '''
			package toto {
				Component A{
					provided = {m1,m2}
					requiered = {m3}

					service provided type2 m1(p1 : type1) {}
					service provided void m2() {}

					service requiered type3 m3(p2 : type4);
				}

				Component B{
					provided = {m4}
					requiered = {m1}

					service provided type3 m4 (p4 : type4) { }

					service requiered type2 m1 (p3 : type1);
				}

				Assembly Foo{
					components
					a1 : A
					a2 : A
					b1 : B
					bindings
				}
			}
		'''

		input2.parse.assertError(
			FooPackage.Literals.ASSEMBLY,
			FooValidator.CHECK_ASSEMBLY_IS_VALID,
			input.indexOf("Foo"),
			"Foo".length,
			"The assembly is not correct, there are missing bindings")
	}
}
