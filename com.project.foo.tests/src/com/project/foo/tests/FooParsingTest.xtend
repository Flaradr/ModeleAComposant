/*
 * generated by Xtext 2.13.0
 */
package com.project.foo.tests

import com.google.inject.Inject
import com.project.foo.foo.DomainModel
import com.project.foo.foo.FooPackage
import com.project.foo.validation.FooValidator
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*

@RunWith(XtextRunner)
@InjectWith(FooInjectorProvider)
class FooParsingTest {
	@Inject extension ParseHelper<DomainModel>
	@Inject extension ValidationTestHelper

	val static validComponent = '''
		package toto {
			Component A{
				provided = {m1,m2}
				required = {m3}

				service provided type2 m1(p1 : type2) {
					Lorem Ipsum;
				}
				service provided type1 m2(p2 : type1) {
					Foo;
				}

				service required type3 m3();
			}
		}'''

	/**
	 * Test si le composant est valide ou non
	 */
	@Test
	def void testParsingComponent() {
		val input = parse(validComponent)
		assertNotNull(input)
		val errors = input.eResource.errors
		val component = input.model.components.get(0)
		assertEquals("A",component.name)

		/*Comment tester égalités entre tableau alors qu'il faudrait mapper
		 * .name à chaque attribut de component.provided.providedServices
		 * et component.required.requiredServices ?
		 */
		//assertEquals("[m1,m2]",component.provided.providedServices)
		//assertEquals("[m3]",component.required.requiredServices)

		assertTrue('''Unexpected errors: «errors.join(", ")»''', errors.isEmpty)
	}

	/**
	 * Test la methode checkComponentNameStartsWithCapital
	 */
	@Test
	def void testCheckComponentNameStartsWithCapital(){
		validComponent.parse.assertNoIssues()

		val input = '''
			package toto {
				Component a{
					provided = {m1}
					required = {}

					service provided type2 m1(p1 : type2) {}
				}
			}
		'''
		input.parse.assertWarning(
			FooPackage.Literals.COMPONENT,
			FooValidator.CHECK_C_NAME_START_W_CAPITAL,
			input.indexOf("Component a")+"Component ".length,
			1,
			"Name should start with a capital")
	}

	/**
	 * Test la methode checkAssemblyNameStartsWithCapital
	 */
	@Test
	def void testCheckAssemblyNameStartsWithCapital(){
		val inputOk = '''
			package toto {
				Component A{
					provided = {m1}
					required = {}

					service provided type2 m1(p1 : type2) {
						Foo;
					}
				}
				Component B{
					provided = {m2}
					required = {}

					service provided type2 m2(p1 : type2) {
						Bar;
					}
				}
				Assembly D{
					components
					a1 : A
					b1 : B
					bindings
				}
			}
		'''
		inputOk.parse.assertNoIssues()

		val input = '''
			package toto {
				Component A{
					provided = {m1}
					required = {}

					service provided type2 m1(p1 : type2) {
						Foo;
					}
				}
				Component B{
					provided = {m2}
					required = {}

					service provided type2 m2(p1 : type2) {
						Bar;
					}
				}
				Assembly d{
					components
					a1 : A
					b1 : B
					bindings
				}
			}
		'''
		input.parse.assertWarning(
			FooPackage.Literals.ASSEMBLY,
			FooValidator.CHECK_A_NAME_START_W_CAPITAL,
			input.indexOf("Assembly d")+"Assembly ".length,	//Ajout de "Assembly ".length pour eviter ambiguite
			1,
			"Name should start with a capital")
	}

	/*************************************************************
	 * 				Test check unicite nom						 *
	 * ********************************************************* */
	/**
	 * Test la methode checkComponentNameIsUnique
	 */
	@Test
	def void testCheckComponentNameIsUnique(){
		validComponent.parse.assertNoIssues()

		val input = '''
			package toto {
				Component A{
					provided = {m1,m2}
					required = {m3}

					service provided type2 m1(p1 : type2) {foo;}
					service provided type1 m2(p2 : type1) {bar;}

					service required type3 m3();
				}
				
				Component A{
					provided = {m7}
					required = {}

					service provide type1 m7() {barfoo;}
				}
			}
		'''
		input.parse.assertError(
			FooPackage.Literals.COMPONENT,
			FooValidator.CHECK_COMPONENT_NAME_IS_UNIQUE,
			input.indexOf("Component A")+"Component ".length,
			1,
			"The name of a component should be unique")
		}

	/**
	 * Test la methode checkAssemblyNameIsUnique
	 */
	@Test
	def void testCheckAssemblyNameIsUnique(){
		val inputOk = '''
		package toto {
			Component A{
				provided = {m1}
				required = {}

				service provided type2 m1(p1 : type2) {foo;}
			}
			
			Component B{
				provided = {m2}
				required = {}

				service provided type2 m2(p1 : type2) {bar;}
			}
			
			Assembly D{
				components
				a1 : A
				b1 : B
				bindings
			}
			
			Assembly F{
				components
				a1 : A
				b2 : B
				bindings
			}
		}
		'''
		inputOk.parse.assertNoIssues()

		val input = '''
		package toto {
			Component A{
				provided = {m1}
				required = {}

				service provided type2 m1(p1 : type2) {foo;}
			}
			
			Component B{
				provided = {m2}
				required = {}

				service provided type2 m2(p1 : type2) {bar;}
			}
			
			Assembly D{
				components
				a1 : A
				b1 : B
				bindings
			}
			
			Assembly D{
				components
				a1 : A
				b2 : B
				bindings
			}
		}
		'''
		input.parse.assertError(
			FooPackage.Literals.ASSEMBLY,
			FooValidator.CHECK_ASSEMBLY_NAME_IS_UNIQUE,
			input.indexOf("Assembly D")+"Assembly ".length,
			1,
			"The name of an assembly should be unique")
	}

	/**
	 * Teste la methode checkComponentAttributeNameIsUnique
	 */
	@Test
	def void testCheckComponentAttributeNameIsUnique(){
		val inputOk = '''
		package toto {
			Component A{
				provided = {m1}
				required = {}

				service provided type2 m1(p1 : type2) {foo;}
			}
			
			Component B{
				provided = {m2}
				required = {}

				service provided type2 m2(p1 : type2) {bar;}
			}
			
			Assembly D{
				components
				a1 : A
				b1 : B
				bindings
			}
		}
		'''
		inputOk.parse.assertNoIssues()

		val input = '''
		package toto {
			Component A{
				provided = {m1}
				required = {}

				service provided type2 m1(p1 : type2) {foobar;}
			}
			Component B{
				provided = {m2}
				required = {}

				service provided type2 m2(p1 : type2) {barfoo;}
			}
			Assembly D{
				components
				a1 : A
				a1 : B
				b1 : B
				bindings
			}
		}
		'''
		input.parse.assertError(
			FooPackage.Literals.COMPONENT_INSTANCE,
			FooValidator.CHECK_COMPONENT_ATTRIBUTE_NAME_IS_UNIQUE,
			input.indexOf("a1"),
			2,
			"The name of a component attribute should be unique")
	}

	/**
	 * Teste la methode checkProvidedServiceNameIsUnique
	 */
	@Test
	def void testCheckProvidedServiceNameIsUnique(){
		validComponent.parse.assertNoIssues()

		val input = '''
			package toto {
				Component A{
					provided = {m1,m1}
					required = {}

					service provided type1 m1() {}
				}
			}
			'''
		input.parse.assertError(
			FooPackage.Literals.PROVIDED_SERVICE,
			FooValidator.CHECK_P_SERVICE_NAME_IS_UNIQUE,
			input.indexOf("m1"),
			2,
			"The name of a provided service should be unique in a component")
	}


	/**
	 * Teste la methode checkRequieredServiceNameIsUnique
	 */
	@Test
	def void testCheckRequieredServiceNameIsUnique(){
		validComponent.parse.assertNoIssues()

		val input = '''
			package toto{
				Component A{
					provided = {m1}
					required = {m2,m2}

					service provided type1 m1() {foo;}
					service required type3 m2();
				}
			}
			'''
		input.parse.assertError(
			FooPackage.Literals.REQUIRED_SERVICE,
			FooValidator.CHECK_R_SERVICE_NAME_IS_UNIQUE,
			input.indexOf("m2"),
			2,
			"The name of a required service should be unique in a component")
	}

	/*************************************************************
	 * 				Test check validite binding					 *
	 * ********************************************************* */

	/**
	 * Teste la methode CheckBindingIsValid
	 */
	@Test
	def void testCheckBindingIsValid(){
		val inputOk = '''
			package toto {
			  	Component A{
			  		provided = {m0}
			  		required = {m1}

			  		service provided type0 m0() {
			  			Foo;
			  		}
			  		service required type1 m1 ();
			  	}

			  	Component B{
			  		provided = {m2}
			  		required = {}

			  		service provided type1 m2(){
			  			Bar;
			  		}
			  	}

			  	Assembly T{
			  		components
			  		a1 : A
			  		b1 : B
			  		bindings
			  		a1.m1 - b1.m2
			  	}
			}
	  	'''
	  	inputOk.parse.assertNoIssues()

	  	val input1 = '''
			package toto {
			  	Component A{
			  		provided = {m0}
			  		required = {m1}

			  		service provided type0 m0() {
			  			Foo;
			  		}
			  		service required type1 m1 (p1 : type1, p2 : type2);
			  	}

			  	Component B{
			  		provided = {m2}
			  		required = {}

			  		service provided type2 m2(p21 : type1, p22 : type2){
			  			Bar;
			  		}
			  	}

			  	Assembly T{
			  		components
			  		a1 : A
			  		b1 : B
			  		bindings
			  		a1.m1 - b1.m2
			  	}
			 }
	  	'''
	  	input1.parse.assertError(
	  		FooPackage.Literals.BINDING,
	  		FooValidator.CHECK_BINDING_IS_VALID,
	  		input1.indexOf("b1.m2"),
	  		"b1.m2".length,
	  		"Return type of the provided service do not match the return type of the required service")

	  	val input2 = '''
			package toto {
			  	Component A{
			  		provided = {m0}
			  		required = {m1}

			  		service provided type0 m0() {
			  			Foo;
			  		}
			  		service required type2 m1 (p1 : type1, p2 : type2);
			  	}

			  	Component B{
			  		provided = {m2}
			  		required = {}

			  		service provided type2 m2(p7 : type1, p3 : type3){
			  			Bar;
			  		}
			  	}

			  	Assembly T{
			  		components
			  		a1 : A
			  		b1 : B
			  		bindings
			  		a1.m1 - b1.m2
			  	}
			 }
	  	'''
	  	input2.parse.assertError(
	  		FooPackage.Literals.BINDING,
	  		FooValidator.CHECK_BINDING_IS_VALID,
	  		input2.indexOf("b1.m2"),
	  		"b1.m2".length,
	  		"The type of the parameters of the required service and the provided service do not match")

	  	val input3 = '''
			package toto {
			  	Component A{
			  		provided = {m0}
			  		required = {m1}

			  		service provided type0 m0() {
			  			Foo;
			  		}
			  		service required type2 m1 (p1 : type1, p2 : type2, p3 : type0);
			  	}

			  	Component B{
			  		provided = {m2}
			  		required = {}

			  		service provided type2 m2(p7 : type1, p3 : type3){
			  			Bar;
			  		}
			  	}

			  	Assembly T{
			  		components
			  		a1 : A
			  		b1 : B
			  		bindings
			  		a1.m1 - b1.m2
			  	}
			}
	  	'''
	  	input3.parse.assertError(
	  		FooPackage.Literals.BINDING,
	  		FooValidator.CHECK_BINDING_IS_VALID,
	  		input3.indexOf("a1.m1"),
	  		"a1.m1".length,
	  		"Number of parameters between the required service and the provided service do not match")

	}


	/**
	 * Teste la mmethode checkAssemblyIsCorrect
	 */
	@Test
	def void testCheckAssemblyIsCorrect(){
		val inputOk = '''
			package toto {
				Component A{
					provided = {m1,m2}
					required = {m3}

					service provided type2 m1(p1 : type1) {
						Foo;
					}
					service provided void m2() {
						bar;
					}

					service required type3 m3(p2 : type4);
				}

				Component B{
					provided = {m4}
					required = {m1}

					service provided type3 m4 (p4 : type4) { 
						while(!false){
							toto;
						}
					}

					service required type2 m1 (p3 : type1);
				}

				Assembly Foo{
					components
					a1 : A
					a2 : A
					b1 : B
					bindings
					a1.m3 - b1.m4
					a2.m3 - b1.m4
					b1.m1 - a1.m1
				}
			}
		'''
		inputOk.parse.assertNoIssues

		val input = '''
			package toto {
				Component A{
					provided = {m1,m2}
					required = {m3}

					service provided type2 m1(p1 : type1) {
						foo;
					}
					service provided void m2() {
						Bar;
					}

					service required type3 m3(p2 : type4);
				}

				Component B{
					provided = {m4}
					required = {m1}

					service provided type3 m4 (p4 : type4) { 
						foobar;
					}

					service required type2 m1 (p3 : type1);
				}

				Assembly Foo{
					components
					a1 : A
					a2 : A
					b1 : B
					bindings
					a1.m3 - b1.m4
					b1.m1 - a1.m1
				}
			}
		'''
		input.parse.assertError(
			FooPackage.Literals.ASSEMBLY,
			FooValidator.CHECK_ASSEMBLY_IS_VALID,
			input.indexOf("Foo"),
			"Foo".length,
			"The assembly is not correct, there are missing bindings")

		val input2 = '''
			package toto {
				Component A{
					provided = {m1,m2}
					required = {m3}

					service provided type2 m1(p1 : type1) {
						foo;
					}
					service provided void m2() {
						Bar;
					}

					service required type3 m3(p2 : type4);
				}

				Component B{
					provided = {m4}
					required = {m1}

					service provided type3 m4 (p4 : type4) { 
						foobar;
					}

					service required type2 m1 (p3 : type1);
				}

				Assembly Foo{
					components
					a1 : A
					a2 : A
					b1 : B
					bindings
				}
			}
		'''

		input2.parse.assertError(
			FooPackage.Literals.ASSEMBLY,
			FooValidator.CHECK_ASSEMBLY_IS_VALID,
			input.indexOf("Foo"),
			"Foo".length,
			"The assembly is not correct, there are missing bindings")
	}

	@Test
	def void testCheckBindingRequieredCanUseMethod(){
		val inputOk = '''
			package my.company.firstPack {
				import my.company.secondPack.*
			
				Component A{
					provided = {m1,m2,m8}
					required = {m3}
			
					service provided type2 m1(p1 : type1) {foo;}
					service provided void m2() {b;}
					service provided type3 m8(p8 : type3, p9 : type4) {
						while(K.equals(p) && !bar){
							foo;
						}
					}
			
					service required type3 m3(p2 : type4);
				}
			
				Component B{
					provided = {m3}
					required = {m1,m4}
			
					service provided type3 m3 (p4 : type4) {f; }
			
					service required type2 m1 (p3 : type1);
					service required type3 m4 (p4_1 : type3, p4_2 : type4);
				}
			
				Assembly Foo{
					components
					a1 : A
					a2 : A
					b1 : B
					bindings
					a1.m3 - b1.m3
					a2.m3 - b1.m3
					b1.m1 - a1.m1
					b1.m4 - a2.m8
				}
			}
		'''
		inputOk.parse.assertNoIssues()
		
		val input = '''
		package my.company.firstPack {
			import my.company.secondPack.*
		
			Component A{
				provided = {m1,m2,m8}
				required = {m3}
		
				service provided type2 m1(p1 : type1) {foo;}
				service provided void m2() {bar;}
				service provided type3 m8(p8 : type3, p9 : type4) {foobar;}
		
				service required type3 m3(p2 : type4);
			}
		
			Component B{
				provided = {m3}
				required = {m1,m4}
		
				service provided type3 m3 (p4 : type4) { foobar; }
				service required type2 m1 (p3 : type1);
				service required type3 m4 (p4_1 : type3, p4_2 : type4);
			}
		
			Assembly Foo{
				components
				a1 : A
				a2 : A
				b1 : B
				bindings
				b1.m3 - b1.m3
				a1.m3 - b1.m3
				a2.m3 - b1.m3
				b1.m1 - a1.m1
				b1.m4 - a2.m8
			}
		}
		'''

		input.parse.assertError(
			FooPackage.Literals.BINDING_REQUIRED,
			FooValidator.CHECK_BINDING_REQUIERED_CAN_USE_METHOD,
			input.indexOf("b1.m3") + "b1.".length,
			"m3".length,
			"This service is not required by the component")
	}
	
	@Test
	def void testCheckBindingProvidedCanUseMethod(){
		val inputOk = '''
			package my.company.firstPack {
				import my.company.secondPack.*
			
				Component A{
					provided = {m1,m2,m8}
					required = {m3}
			
					service provided type2 m1(p1 : type1) {
						Bar;
					}
					service provided void m2() {
						FooBar;
					}
					service provided type3 m8(p8 : type3, p9 : type4) {
						Bar;
					}
			
					service required type3 m3(p2 : type4);
				}
			
				Component B{
					provided = {m3}
					required = {m1,m4}
			
					service provided type3 m3 (p4 : type4) { 
						Foo;
					}
			
					service required type2 m1 (p3 : type1);
					service required type3 m4 (p4_1 : type3, p4_2 : type4);
				}
			
				Assembly Foo{
					components
					a1 : A
					a2 : A
					b1 : B
					bindings
					a1.m3 - b1.m3
					a2.m3 - b1.m3
					b1.m1 - a1.m1
					b1.m4 - a2.m8
				}
			}
		'''
		inputOk.parse.assertNoIssues()
		
		val input = '''
		package my.company.firstPack {
			Component A{
				provided = {m1,m2,m8,mk8}
				required = {m3,mk0}
		
				service provided type2 m1(p1 : type1) {
					Foo;
				}
				service provided void m2() {
					Foo;
				}
				service provided type3 m8(p8 : type3, p9 : type4) {
					if(true){
						Foo;
					}
				}
				service provided type00 mk8() {
					if (!false && k.equals(bar)){
						foo;
					}
				}
			
				service required type3 m3(p2 : type4);
				service required type00 mk0();
			}
		
			Component B{
				provided = {m3,mk8}
				required = {m1,m4}
		
				service provided type3 m3 (p4 : type4) { 
					Bar;
				}
				service provided type00 mB8() {
					Bar;
				}
		
				service required type2 m1 (p3 : type1);
				service required type3 m4 (p4_1 : type3, p4_2 : type4);
			}
		
			Assembly Foo{
				components
				a1 : A
				a2 : A
				b1 : B
				bindings
				a1.m3 - b1.m3
				a2.m3 - b1.m3
				b1.m1 - a1.m1
				b1.m4 - a2.m8
				a1.mk0 - a1.mB8
				a2.mk0 - b1.mB8
			}
		}
		'''

		input.parse.assertError(
			FooPackage.Literals.BINDING_PROVIDED,
			FooValidator.CHECK_BINDING_PROVIDED_CAN_USE_METHOD,
			input.indexOf("a1.mB8") + "a1.".length,
			"mB8".length,
			"The type of the component and the component requiring this method are not the same")
	}
}
