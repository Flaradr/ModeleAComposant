/*
 * generated by Xtext 2.13.0
 */
package com.project.foo.serializer;

import com.google.inject.Inject;
import com.project.foo.foo.Assembly;
import com.project.foo.foo.Attribute;
import com.project.foo.foo.Binding;
import com.project.foo.foo.BindingProvided;
import com.project.foo.foo.BindingRequiered;
import com.project.foo.foo.Component;
import com.project.foo.foo.ComponentAttribute;
import com.project.foo.foo.DomainModel;
import com.project.foo.foo.FooPackage;
import com.project.foo.foo.Import;
import com.project.foo.foo.MProvidedService;
import com.project.foo.foo.MRequieredService;
import com.project.foo.foo.Model;
import com.project.foo.foo.PSignature;
import com.project.foo.foo.Provided;
import com.project.foo.foo.ProvidedService;
import com.project.foo.foo.RSignature;
import com.project.foo.foo.Requiered;
import com.project.foo.foo.RequieredService;
import com.project.foo.services.FooGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FooSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FooGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FooPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FooPackage.ASSEMBLY:
				sequence_Assembly(context, (Assembly) semanticObject); 
				return; 
			case FooPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case FooPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case FooPackage.BINDING_PROVIDED:
				sequence_BindingProvided(context, (BindingProvided) semanticObject); 
				return; 
			case FooPackage.BINDING_REQUIERED:
				sequence_BindingRequiered(context, (BindingRequiered) semanticObject); 
				return; 
			case FooPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case FooPackage.COMPONENT_ATTRIBUTE:
				sequence_ComponentAttribute(context, (ComponentAttribute) semanticObject); 
				return; 
			case FooPackage.DOMAIN_MODEL:
				sequence_DomainModel(context, (DomainModel) semanticObject); 
				return; 
			case FooPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case FooPackage.MPROVIDED_SERVICE:
				sequence_MProvidedService(context, (MProvidedService) semanticObject); 
				return; 
			case FooPackage.MREQUIERED_SERVICE:
				sequence_MRequieredService(context, (MRequieredService) semanticObject); 
				return; 
			case FooPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case FooPackage.PSIGNATURE:
				sequence_PSignature(context, (PSignature) semanticObject); 
				return; 
			case FooPackage.PROVIDED:
				sequence_Provided(context, (Provided) semanticObject); 
				return; 
			case FooPackage.PROVIDED_SERVICE:
				sequence_ProvidedService(context, (ProvidedService) semanticObject); 
				return; 
			case FooPackage.RSIGNATURE:
				sequence_RSignature(context, (RSignature) semanticObject); 
				return; 
			case FooPackage.REQUIERED:
				sequence_Requiered(context, (Requiered) semanticObject); 
				return; 
			case FooPackage.REQUIERED_SERVICE:
				sequence_RequieredService(context, (RequieredService) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Assembly returns Assembly
	 *
	 * Constraint:
	 *     (name=ID attributes+=ComponentAttribute attributes+=ComponentAttribute+ bindings+=Binding*)
	 */
	protected void sequence_Assembly(ISerializationContext context, Assembly semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID type=ID)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.ATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.ATTRIBUTE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getTypeIDTerminalRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BindingProvided returns BindingProvided
	 *
	 * Constraint:
	 *     (name=[ComponentAttribute|ID] type=[ProvidedService|QualifiedName])
	 */
	protected void sequence_BindingProvided(ISerializationContext context, BindingProvided semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.BINDING_PROVIDED__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.BINDING_PROVIDED__NAME));
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.BINDING_PROVIDED__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.BINDING_PROVIDED__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingProvidedAccess().getNameComponentAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FooPackage.Literals.BINDING_PROVIDED__NAME, false));
		feeder.accept(grammarAccess.getBindingProvidedAccess().getTypeProvidedServiceQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(FooPackage.Literals.BINDING_PROVIDED__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BindingRequiered returns BindingRequiered
	 *
	 * Constraint:
	 *     (name=[ComponentAttribute|ID] type=[RequieredService|QualifiedName])
	 */
	protected void sequence_BindingRequiered(ISerializationContext context, BindingRequiered semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.BINDING_REQUIERED__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.BINDING_REQUIERED__NAME));
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.BINDING_REQUIERED__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.BINDING_REQUIERED__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingRequieredAccess().getNameComponentAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FooPackage.Literals.BINDING_REQUIERED__NAME, false));
		feeder.accept(grammarAccess.getBindingRequieredAccess().getTypeRequieredServiceQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(FooPackage.Literals.BINDING_REQUIERED__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (mG=BindingRequiered mD=BindingProvided)
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.BINDING__MG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.BINDING__MG));
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.BINDING__MD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.BINDING__MD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingAccess().getMGBindingRequieredParserRuleCall_0_0(), semanticObject.getMG());
		feeder.accept(grammarAccess.getBindingAccess().getMDBindingProvidedParserRuleCall_2_0(), semanticObject.getMD());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComponentAttribute returns ComponentAttribute
	 *
	 * Constraint:
	 *     (name=ID type=[Component|QualifiedName])
	 */
	protected void sequence_ComponentAttribute(ISerializationContext context, ComponentAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.COMPONENT_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.COMPONENT_ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.COMPONENT_ATTRIBUTE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.COMPONENT_ATTRIBUTE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getComponentAttributeAccess().getTypeComponentQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(FooPackage.Literals.COMPONENT_ATTRIBUTE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (name=ID provided=Provided requiered=Requiered mProvServices+=MProvidedService+ mReqServices+=MRequieredService*)
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainModel returns DomainModel
	 *
	 * Constraint:
	 *     models+=Model+
	 */
	protected void sequence_DomainModel(ISerializationContext context, DomainModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=FqnWithWildCard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceFqnWithWildCardParserRuleCall_3_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MProvidedService returns MProvidedService
	 *
	 * Constraint:
	 *     signature=PSignature
	 */
	protected void sequence_MProvidedService(ISerializationContext context, MProvidedService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.MPROVIDED_SERVICE__SIGNATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.MPROVIDED_SERVICE__SIGNATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMProvidedServiceAccess().getSignaturePSignatureParserRuleCall_2_0(), semanticObject.getSignature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MRequieredService returns MRequieredService
	 *
	 * Constraint:
	 *     signature=RSignature
	 */
	protected void sequence_MRequieredService(ISerializationContext context, MRequieredService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.MREQUIERED_SERVICE__SIGNATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.MREQUIERED_SERVICE__SIGNATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMRequieredServiceAccess().getSignatureRSignatureParserRuleCall_2_0(), semanticObject.getSignature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=QualifiedName imports+=Import* component+=Component* assembly+=Assembly*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PSignature returns PSignature
	 *
	 * Constraint:
	 *     (type=ID name=[ProvidedService|ID] attributes+=Attribute? attributes+=Attribute*)
	 */
	protected void sequence_PSignature(ISerializationContext context, PSignature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProvidedService returns ProvidedService
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ProvidedService(ISerializationContext context, ProvidedService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.PROVIDED_SERVICE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.PROVIDED_SERVICE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProvidedServiceAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Provided returns Provided
	 *
	 * Constraint:
	 *     (providedServices+=ProvidedService providedServices+=ProvidedService*)
	 */
	protected void sequence_Provided(ISerializationContext context, Provided semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RSignature returns RSignature
	 *
	 * Constraint:
	 *     (type=ID name=[RequieredService|ID] attributes+=Attribute? attributes+=Attribute*)
	 */
	protected void sequence_RSignature(ISerializationContext context, RSignature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequieredService returns RequieredService
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_RequieredService(ISerializationContext context, RequieredService semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FooPackage.Literals.REQUIERED_SERVICE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FooPackage.Literals.REQUIERED_SERVICE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequieredServiceAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Requiered returns Requiered
	 *
	 * Constraint:
	 *     (requieredServices+=RequieredService? requieredServices+=RequieredService*)
	 */
	protected void sequence_Requiered(ISerializationContext context, Requiered semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
