/*
 * generated by Xtext 2.13.0
 */
package com.project.foo.validation

import com.project.foo.foo.Assembly
import com.project.foo.foo.Binding
import com.project.foo.foo.BindingProvided
import com.project.foo.foo.BindingRequired
import com.project.foo.foo.Component
import com.project.foo.foo.ComponentInstance
import com.project.foo.foo.FooPackage
import com.project.foo.foo.MProvidedService
import com.project.foo.foo.MRequiredService
import com.project.foo.foo.Parameter
import com.project.foo.foo.ProvidedService
import com.project.foo.foo.RequiredService
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import com.project.foo.foo.Refine

/**
 * This class contains custom validation rules.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class FooValidator extends AbstractFooValidator {

	public static val CHECK_C_NAME_START_W_CAPITAL = "com.projet.foo.foo.checkComponentNameStartsWithCapital"
	public static val CHECK_A_NAME_START_W_CAPITAL = "com.projet.foo.foo.checkAssemblyNameStartsWithCapital"

	public static val CHECK_COMPONENT_NAME_IS_UNIQUE = "com.project.foo.foo.CheckComponentNameIsUnique"
	public static val CHECK_ASSEMBLY_NAME_IS_UNIQUE = "com.project.foo.foo.CheckAssemblyNameIsUnique"
	public static val CHECK_COMPONENT_ATTRIBUTE_NAME_IS_UNIQUE = "com.project.foo.foo.ChecKComponentAttributeNameIsUnique"
	public static val CHECK_P_SERVICE_NAME_IS_UNIQUE = "com.project.foo.foo.CheckProvidedServiceNameIsUnique"
	public static val CHECK_R_SERVICE_NAME_IS_UNIQUE = "com.project.foo.foo.CheckRequieredServiceNameIsUnique"

	//public static val CHECK_LINK_L_OPERAND_BINDING = "com.project.foo.foo.CheckLinkLeftOperandBinding"
	public static val CHECK_BINDING_IS_VALID = "com.project.foo.foo.CheckBindingIsValid"
	public static val CHECK_BINDING_REQUIERED_CAN_USE_METHOD = "com.project.foo.foo.CheckBindingRequieredCanUseMethod"
	public static val CHECK_BINDING_PROVIDED_CAN_USE_METHOD = "com.project.foo.foo.CheckBindingProvidedCanUseMethod"
	
	public static val CHECK_ASSEMBLY_IS_VALID = "com.project.foo.foo.CheckAssemblyIsValid"
	public static val CHECK_IMPORT_IS_VALID = "com.project.foo.foo.CheckImportIsValid"

	@Check
	def void checkComponentNameStartsWithCapital(Component component) {
		if(!Character.isUpperCase(component.name.charAt(0))){
			warning("Name should start with a capital: '"+ component.name +"'",
				 	FooPackage.Literals.COMPONENT__NAME,
					CHECK_C_NAME_START_W_CAPITAL)
		}
	}

	@Check
	def void checkAssemblyNameStartsWithCapital(Assembly assembly){
		if(!Character.isUpperCase(assembly.name.charAt(0))){
			warning("Name should start with a capital: '"+assembly.name+"'",
					FooPackage.Literals.ASSEMBLY__NAME,
					CHECK_A_NAME_START_W_CAPITAL)
		}
	}

	 /*************************************************************
	 * 				       Check unicite nom				  	  *
	 **************************************************************/

	 /**
	  * Verifie qu'il n'y a pas plusieurs composant ayant le meme nom
	  * au sein d'un modele
	  */
	 @Check
	 def void checkComponentNameIsUnique(Component component){
		var tmp = EcoreUtil2.getNextSibling(component)
		while(tmp !== null){
			if (component.name.equals((tmp as Component).name)){
				error("The name of a component should be unique:'"+component.name+"'",
					  FooPackage.Literals.COMPONENT__NAME,
					  CHECK_COMPONENT_NAME_IS_UNIQUE)
			}
			tmp = EcoreUtil2.getNextSibling(tmp)
		}
	  }

	 /**
	  * Verifie qu'il n'y a pas plusieurs assemblage ayant le meme nom
	  * au sein d'un modele
	  */
	 @Check
	 def void checkAssemblyNameIsUnique(Assembly assembly){
	 	var tmp = EcoreUtil2.getNextSibling(assembly)
	 	while(tmp !== null){
			if(assembly.name.equals((tmp as Assembly).name)){
				error("The name of an assembly should be unique :'"+assembly.name+"'",
				      FooPackage.Literals.ASSEMBLY__NAME,
					  CHECK_ASSEMBLY_NAME_IS_UNIQUE)
			}
			tmp = EcoreUtil2.getNextSibling(tmp)
	 	}
	 }

	 /**
	  * Verifie qu'il n'y a pas plusieurs attributs d'un assemblage ayant le meme nom
	  * au sein d'un modele
	  */
	 @Check
	 def void checkComponentAttributeNameIsUnique(ComponentInstance ca){
	 	var tmp = EcoreUtil2.getNextSibling(ca)
	 	while(tmp !== null){
	 		if(ca.name.equals((tmp as ComponentInstance).name)){
	 			error("The name of a component attribute should be unique :'"+ca.name+"'",
	 				  FooPackage.Literals.COMPONENT_INSTANCE__NAME,
	 				  CHECK_COMPONENT_ATTRIBUTE_NAME_IS_UNIQUE)
	 		}
			tmp = EcoreUtil2.getNextSibling(tmp)
	 	}
	 }

	 /**
	  * Verifie qu'il n'y a pas plusieurs services pourvu ayant le meme nom
	  * au sein d'un composant
	  */
	 @Check
	 def void checkProvidedServiceNameIsUnique(ProvidedService ps){
	 	var tmp = EcoreUtil2.getNextSibling(ps)
	 	while(tmp !== null){
	 		if(ps.name.equals((tmp as ProvidedService).name)){
	 			error("The name of a provided service should be unique in a component: '"+ ps.name +"'",
	 				  FooPackage.Literals.PROVIDED_SERVICE__NAME,
	 				  CHECK_P_SERVICE_NAME_IS_UNIQUE)
	 		}
	 		tmp = EcoreUtil2.getNextSibling(tmp)
	 	}
	 }

	 /**
	  * Verifie qu'il n'y a pas plusieurs services requis ayant le meme nom
	  * au sein d'un composant
	  */
	 @Check
	 def void checkRequieredServiceNameIsUnique(RequiredService rs){
	 	var tmp = EcoreUtil2.getNextSibling(rs)
	 	while(tmp !== null){
	 		if(rs.name.equals((tmp as RequiredService).name)){
	 			error("The name of a required service should be unique in a component: '"+rs.name+"'",
	 				FooPackage.Literals.REQUIRED_SERVICE__NAME,
	 				CHECK_R_SERVICE_NAME_IS_UNIQUE)
	 		}
	 		tmp = EcoreUtil2.getNextSibling(tmp)
	 	}
	 }


	 /*************************************************************
	 * 				     Check validite binging  			  	  *
	 **************************************************************/
	
	/**
	 * Verifie que l'instance d'un composant X demande un service requis par 
	 * le composant X et pas un autre 
	 */ 
	@Check
	def void checkBindingRequieredCanUseMethod(BindingRequired bindingRequiered){
		val listOfComponent = (bindingRequiered.name.eContainer as Assembly).attributes
		var res = false
		var i = 0
		var String typeOfInstance
		while (i < listOfComponent.size() && !res){
			if (listOfComponent.get(i).name.equals(bindingRequiered.name.name)){
				res = true
				typeOfInstance = listOfComponent.get(i).component.name
			}
			i++
		}
		
		val componentTypeOfService = (bindingRequiered.service.eContainer.eContainer as Component).name

		if (!typeOfInstance.equals(componentTypeOfService)){
			error("This service is not required by the component",
				  FooPackage.Literals.BINDING_REQUIRED__SERVICE,
				  CHECK_BINDING_REQUIERED_CAN_USE_METHOD)
		}
	}
	
	/**
	 * Verifie que l'instance d'un composant X demande un service fourni par 
	 * le composant X et pas un autre 
	 */ 
	@Check
	def void checkBindingProvidedCanUseMethod(BindingProvided bindingProvided){
		val listOfComponent = (bindingProvided.name.eContainer as Assembly).attributes
		var res = false
		var i = 0
		var String typeOfInstance
		while (i < listOfComponent.size() && !res){
			if (listOfComponent.get(i).name.equals(bindingProvided.name.name)){
				res = true
				typeOfInstance = listOfComponent.get(i).component.name
			}
			i++
		}
		val componentTypeOfService = (bindingProvided.service.eContainer.eContainer as Component).name
		
		if (!typeOfInstance.equals(componentTypeOfService)){
			error("The type of the component and the component requiring this method are not the same",
				  FooPackage.Literals.BINDING_PROVIDED__SERVICE,
				  CHECK_BINDING_PROVIDED_CAN_USE_METHOD)
		}
	}
	
	/**
	 * Verifie qu'un binding est valide
	 * i.e. Pas d'erreur si la signature et le type de retour
	 *  d'un service fourni et d'un service requis sont identique
	 * @param binding en cours d'analyse
	 * @error <b>Return type of the provided service do not match the return type of the required service</b>
	 * if the signatures or the return type do not match
	 */
	@Check
	def void checkBindingIsValid(Binding binding){
		val nomMethodG = binding.bindingRequired.service
		val nomMethodD = binding.bindingProvided.service
		val listOfRequieredServices = (binding.bindingRequired.service.eContainer().eContainer() as Component).MReqServices
		val listOfProvidedServices = (binding.bindingProvided.service.eContainer().eContainer() as Component).MProvServices	
		
	
		var String valRetMReq = ""
		var String valRetMProv = ""
		var EList<Parameter> signatureofRequieredMethod
		var EList<Parameter> signatureOfProvidedMethod

		for(MRequiredService foo : listOfRequieredServices){
			if (foo.signature.name.equals(nomMethodG.name)){//Remettre foo.signature.name.name si changement de grammaire ne fonctionne pas
				valRetMReq = foo.signature.type
				signatureofRequieredMethod = foo.signature.parameters
			}
		}
		for(MProvidedService foo : listOfProvidedServices){
			if(foo.signature.name.equals(nomMethodD.name)){	//Remettre foo.signature.name.name si changement de grammaire ne fonctionne pas
				valRetMProv = foo.signature.type
				signatureOfProvidedMethod = foo.signature.parameters
			}
		}
		
		if (!valRetMReq.equals(valRetMProv)){
			error("Return type of the provided service do not match the return type of the required service",
				  FooPackage.Literals.BINDING__BINDING_PROVIDED,
				  CHECK_BINDING_IS_VALID)
		}

		signatureEquals(signatureofRequieredMethod,signatureOfProvidedMethod)
	}

	/**
	 * Vérifie que les parametres des signatures de deux methodes sont dans le même ordre
	 * et que pour tout parametre a la position i dans les deux signature le type du parametre est identique
	 * @param signature1 : signature de la methode d'un service requis
	 * @param signature2 : signature de la methode d'un service pourvu
	 */
	def signatureEquals(EList<Parameter> signature1, EList<Parameter> signature2){
		if(!(signature1.size() == signature2.size())){
			error("Number of parameters between the required service and the provided service do not match",
				  FooPackage.Literals.BINDING__BINDING_REQUIRED,
				  CHECK_BINDING_IS_VALID)
			return
		}
		var int i = 0
		var boolean res = true
		while (i < signature1.size() && res){
			if(!(signature1.get(i).type.equals(signature2.get(i).type))){
				error("The type of the parameters of the required service and the provided service do not match",
					  FooPackage.Literals.BINDING__BINDING_PROVIDED,
					  CHECK_BINDING_IS_VALID)
			}
			i++
		}
	}
 
	/**
	 * Verifie qu'un assemblage est correct
	 * i.e. Verifie que les services requis par l'ensemble des composants
	 * constituant l'assemblage sont lié à des services fournis dans la section
	 * bindings de l'assemblage
	 */
	@Check
	def void checkAssemblyIsCorrect(Assembly assembly){
		var listeComposants = assembly.attributes
		for (ComponentInstance component : listeComposants){//Recupere liste des composants dans l'assemblage
			var listeServicesRequis = (component.component as Component).listOfRServices.requiredServices
			for(RequiredService service : listeServicesRequis){//Liste des services requis dans un composant
				var listeBindings = assembly.bindings
			 	if(listeBindings.isEmpty() && !listeServicesRequis.isEmpty()){
					error("The assembly is not correct, there are missing bindings",
						  FooPackage.Literals.ASSEMBLY__NAME,
						  CHECK_ASSEMBLY_IS_VALID)
					return
				}
				
				for(Binding binding : listeBindings){//Liste des bindings dans l'assemblage
					var int i = 0
					var boolean isPresent = false
					while (i < listeBindings.size() && !isPresent){
						if(service.name.name.equals(listeBindings.get(i).bindingRequired.service.name) && //Comparaison de la méthode requise par l'instance du composant en cours et celle du binding
							component.name.equals(listeBindings.get(i).bindingRequired.name.name)
						){
							isPresent = true
						}
						i++
					}
					if (!isPresent){
						error("The assembly is not correct, there are missing bindings",
							  FooPackage.Literals.ASSEMBLY__NAME,
							  CHECK_ASSEMBLY_IS_VALID)
					}
				}
			}
		}
	}
	
	@Check
	def void checkRefinementIsPossible(Refine ref){
		var eltToRefineName = ref.eltToRefine.eClass.name
		var refiningEltName = ref.refiningElt.eClass.name
		
		if (!eltToRefineName.equals(refiningEltName)){
			error("The refinement cannot be between a component and a binding",
				  null)
		}
	}
	
}
